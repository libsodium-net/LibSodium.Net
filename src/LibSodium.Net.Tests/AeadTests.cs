
// <auto-generated />
using LibSodium.Net.Tests;
using System.Text;

namespace LibSodium.Tests
{
    public class XChaCha20Poly1305Tests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[XChaCha20Poly1305.NonceLen + plaintext.Length + XChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[XChaCha20Poly1305.NonceLen + plaintext.Length + XChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[XChaCha20Poly1305.MacLen];
            Span<byte> encrypted;

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + XChaCha20Poly1305.MacLen + XChaCha20Poly1305.NonceLen];
            XChaCha20Poly1305.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class Aegis256Tests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis256.NonceLen + plaintext.Length + Aegis256.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key);
            Aegis256.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, aad: aad);
            Aegis256.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis256.NonceLen + plaintext.Length + Aegis256.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[Aegis256.MacLen];
            Span<byte> encrypted;

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[Aegis256.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + Aegis256.MacLen + Aegis256.NonceLen];
            Aegis256.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            Aegis256.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class Aes256GcmTests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aes256Gcm.NonceLen + plaintext.Length + Aes256Gcm.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key);
            Aes256Gcm.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, aad: aad);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aes256Gcm.NonceLen + plaintext.Length + Aes256Gcm.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[Aes256Gcm.MacLen];
            Span<byte> encrypted;

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[Aes256Gcm.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + Aes256Gcm.MacLen + Aes256Gcm.NonceLen];
            Aes256Gcm.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            Aes256Gcm.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class ChaCha20Poly1305IetfTests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305Ietf.NonceLen + plaintext.Length + ChaCha20Poly1305Ietf.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, aad: aad);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305Ietf.NonceLen + plaintext.Length + ChaCha20Poly1305Ietf.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[ChaCha20Poly1305Ietf.MacLen];
            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[ChaCha20Poly1305Ietf.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + ChaCha20Poly1305Ietf.MacLen + ChaCha20Poly1305Ietf.NonceLen];
            ChaCha20Poly1305Ietf.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            ChaCha20Poly1305Ietf.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class ChaCha20Poly1305Tests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305.NonceLen + plaintext.Length + ChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305.NonceLen + plaintext.Length + ChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[ChaCha20Poly1305.MacLen];
            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[ChaCha20Poly1305.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + ChaCha20Poly1305.MacLen + ChaCha20Poly1305.NonceLen];
            ChaCha20Poly1305.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            ChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class Aegis128LTests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis128L.NonceLen + plaintext.Length + Aegis128L.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key);
            Aegis128L.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, aad: aad);
            Aegis128L.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis128L.NonceLen + plaintext.Length + Aegis128L.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[Aegis128L.MacLen];
            Span<byte> encrypted;

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[Aegis128L.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + Aegis128L.MacLen + Aegis128L.NonceLen];
            Aegis128L.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            Aegis128L.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
}

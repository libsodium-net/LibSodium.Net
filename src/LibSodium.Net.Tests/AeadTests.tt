<#@ template language="C#" debug="false" hostspecific="false" #>
<#@ output extension=".cs" #>
<#@ import namespace="System" #>

<#
var algorithms = new[] {
    new {
        Name = "XChaCha20Poly1305",
        LowLevel = "LowLevel.XChaCha20Poly1305"
    },
    new {
        Name = "Aegis256",
        LowLevel = "LowLevel.Aegis256"
    },
    new {
        Name = "Aes256Gcm",
        LowLevel = "LowLevel.Aes256Gcm"
    },
    new {
        Name = "ChaCha20Poly1305Ietf",
        LowLevel = "LowLevel.ChaCha20Poly1305Ietf"
    },
    new {
        Name = "ChaCha20Poly1305",
        LowLevel = "LowLevel.ChaCha20Poly1305"
    },
    new {
        Name = "Aegis128L",
        LowLevel = "LowLevel.Aegis128L"
    }
};
#>
// <auto-generated />
using LibSodium.Net.Tests;
using System.Text;

namespace LibSodium.Tests
{
<# foreach (var algo in algorithms) { #>
    public class <#= algo.Name #>Tests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<<#= algo.LowLevel #>>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(<#= algo.Name #>.KeyLen);
            var nonce = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(<#= algo.Name #>.NonceLen);
            var aad = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(64);
            var ciphertext = new byte[<#= algo.Name #>.NonceLen + plaintext.Length + <#= algo.Name #>.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key, aad: aad);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(<#= algo.Name #>.KeyLen);
            var nonce = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(<#= algo.Name #>.NonceLen);
            var aad = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<<#= algo.LowLevel #>>.GenerateRandomBytes(64);
            var ciphertext = new byte[<#= algo.Name #>.NonceLen + plaintext.Length + <#= algo.Name #>.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[<#= algo.Name #>.MacLen];
            Span<byte> encrypted;

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key, mac: mac);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = <#= algo.Name #>.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            <#= algo.Name #>.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[<#= algo.Name #>.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + <#= algo.Name #>.MacLen + <#= algo.Name #>.NonceLen];
            <#= algo.Name #>.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            <#= algo.Name #>.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
<# } #>
}

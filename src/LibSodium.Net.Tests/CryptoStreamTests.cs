

// <auto-generated />
using System.Text;

namespace LibSodium.Tests;

public class CryptoStreamXSalsa20Tests
{
	[Test]
	public void EncryptDecrypt_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamXSalsa20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamXSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream cipher test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamXSalsa20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamXSalsa20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void GenerateKeystream_ShouldBeDeterministic()
	{
		Span<byte> key = stackalloc byte[CryptoStreamXSalsa20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamXSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		Span<byte> keystream1 = stackalloc byte[64];
		Span<byte> keystream2 = stackalloc byte[64];

		CryptoStreamXSalsa20.GenerateKeystream(keystream1, nonce, key);
		CryptoStreamXSalsa20.GenerateKeystream(keystream2, nonce, key);

		keystream1.ShouldBe(keystream2);
	}

	[Test]
	public void Encrypt_InvalidKeyLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamXSalsa20.KeyLen - 1];
			Span<byte> nonce = stackalloc byte[CryptoStreamXSalsa20.NonceLen];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamXSalsa20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void Encrypt_InvalidNonceLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamXSalsa20.KeyLen];
			Span<byte> nonce = stackalloc byte[CryptoStreamXSalsa20.NonceLen - 1];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamXSalsa20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void EncryptDecrypt_Stream_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamXSalsa20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamXSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream test over Stream");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamXSalsa20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamXSalsa20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_ShouldRoundtrip()
	{
		byte[] key = new byte[CryptoStreamXSalsa20.KeyLen];
		byte[] nonce = new byte[CryptoStreamXSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("async stream encryption test");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamXSalsa20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamXSalsa20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamXSalsa20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamXSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure stream test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamXSalsa20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamXSalsa20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_Stream_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamXSalsa20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamXSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream encryption test");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamXSalsa20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamXSalsa20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamXSalsa20.KeyLen);
		byte[] nonce = new byte[CryptoStreamXSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure async stream");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamXSalsa20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamXSalsa20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}
}
public class CryptoStreamSalsa20Tests
{
	[Test]
	public void EncryptDecrypt_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamSalsa20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream cipher test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamSalsa20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamSalsa20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void GenerateKeystream_ShouldBeDeterministic()
	{
		Span<byte> key = stackalloc byte[CryptoStreamSalsa20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		Span<byte> keystream1 = stackalloc byte[64];
		Span<byte> keystream2 = stackalloc byte[64];

		CryptoStreamSalsa20.GenerateKeystream(keystream1, nonce, key);
		CryptoStreamSalsa20.GenerateKeystream(keystream2, nonce, key);

		keystream1.ShouldBe(keystream2);
	}

	[Test]
	public void Encrypt_InvalidKeyLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamSalsa20.KeyLen - 1];
			Span<byte> nonce = stackalloc byte[CryptoStreamSalsa20.NonceLen];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamSalsa20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void Encrypt_InvalidNonceLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamSalsa20.KeyLen];
			Span<byte> nonce = stackalloc byte[CryptoStreamSalsa20.NonceLen - 1];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamSalsa20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void EncryptDecrypt_Stream_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamSalsa20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream test over Stream");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamSalsa20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamSalsa20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_ShouldRoundtrip()
	{
		byte[] key = new byte[CryptoStreamSalsa20.KeyLen];
		byte[] nonce = new byte[CryptoStreamSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("async stream encryption test");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamSalsa20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamSalsa20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamSalsa20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure stream test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamSalsa20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamSalsa20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_Stream_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamSalsa20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream encryption test");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamSalsa20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamSalsa20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamSalsa20.KeyLen);
		byte[] nonce = new byte[CryptoStreamSalsa20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure async stream");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamSalsa20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamSalsa20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}
}
public class CryptoStreamChaCha20Tests
{
	[Test]
	public void EncryptDecrypt_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamChaCha20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream cipher test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamChaCha20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamChaCha20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void GenerateKeystream_ShouldBeDeterministic()
	{
		Span<byte> key = stackalloc byte[CryptoStreamChaCha20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		Span<byte> keystream1 = stackalloc byte[64];
		Span<byte> keystream2 = stackalloc byte[64];

		CryptoStreamChaCha20.GenerateKeystream(keystream1, nonce, key);
		CryptoStreamChaCha20.GenerateKeystream(keystream2, nonce, key);

		keystream1.ShouldBe(keystream2);
	}

	[Test]
	public void Encrypt_InvalidKeyLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamChaCha20.KeyLen - 1];
			Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20.NonceLen];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamChaCha20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void Encrypt_InvalidNonceLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamChaCha20.KeyLen];
			Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20.NonceLen - 1];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamChaCha20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void EncryptDecrypt_Stream_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamChaCha20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream test over Stream");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamChaCha20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamChaCha20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_ShouldRoundtrip()
	{
		byte[] key = new byte[CryptoStreamChaCha20.KeyLen];
		byte[] nonce = new byte[CryptoStreamChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("async stream encryption test");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamChaCha20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamChaCha20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamChaCha20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure stream test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamChaCha20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamChaCha20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_Stream_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamChaCha20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream encryption test");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamChaCha20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamChaCha20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamChaCha20.KeyLen);
		byte[] nonce = new byte[CryptoStreamChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure async stream");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamChaCha20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamChaCha20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}
}
public class CryptoStreamXChaCha20Tests
{
	[Test]
	public void EncryptDecrypt_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamXChaCha20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamXChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream cipher test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamXChaCha20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamXChaCha20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void GenerateKeystream_ShouldBeDeterministic()
	{
		Span<byte> key = stackalloc byte[CryptoStreamXChaCha20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamXChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		Span<byte> keystream1 = stackalloc byte[64];
		Span<byte> keystream2 = stackalloc byte[64];

		CryptoStreamXChaCha20.GenerateKeystream(keystream1, nonce, key);
		CryptoStreamXChaCha20.GenerateKeystream(keystream2, nonce, key);

		keystream1.ShouldBe(keystream2);
	}

	[Test]
	public void Encrypt_InvalidKeyLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamXChaCha20.KeyLen - 1];
			Span<byte> nonce = stackalloc byte[CryptoStreamXChaCha20.NonceLen];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamXChaCha20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void Encrypt_InvalidNonceLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamXChaCha20.KeyLen];
			Span<byte> nonce = stackalloc byte[CryptoStreamXChaCha20.NonceLen - 1];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamXChaCha20.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void EncryptDecrypt_Stream_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamXChaCha20.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamXChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream test over Stream");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamXChaCha20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamXChaCha20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_ShouldRoundtrip()
	{
		byte[] key = new byte[CryptoStreamXChaCha20.KeyLen];
		byte[] nonce = new byte[CryptoStreamXChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("async stream encryption test");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamXChaCha20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamXChaCha20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamXChaCha20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamXChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure stream test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamXChaCha20.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamXChaCha20.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_Stream_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamXChaCha20.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamXChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream encryption test");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamXChaCha20.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamXChaCha20.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamXChaCha20.KeyLen);
		byte[] nonce = new byte[CryptoStreamXChaCha20.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure async stream");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamXChaCha20.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamXChaCha20.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}
}
public class CryptoStreamChaCha20IetfTests
{
	[Test]
	public void EncryptDecrypt_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamChaCha20Ietf.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20Ietf.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream cipher test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamChaCha20Ietf.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamChaCha20Ietf.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void GenerateKeystream_ShouldBeDeterministic()
	{
		Span<byte> key = stackalloc byte[CryptoStreamChaCha20Ietf.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20Ietf.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		Span<byte> keystream1 = stackalloc byte[64];
		Span<byte> keystream2 = stackalloc byte[64];

		CryptoStreamChaCha20Ietf.GenerateKeystream(keystream1, nonce, key);
		CryptoStreamChaCha20Ietf.GenerateKeystream(keystream2, nonce, key);

		keystream1.ShouldBe(keystream2);
	}

	[Test]
	public void Encrypt_InvalidKeyLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamChaCha20Ietf.KeyLen - 1];
			Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20Ietf.NonceLen];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamChaCha20Ietf.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void Encrypt_InvalidNonceLength_ShouldThrow()
	{
		AssertLite.Throws<ArgumentException>(() =>
		{
			Span<byte> key = stackalloc byte[CryptoStreamChaCha20Ietf.KeyLen];
			Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20Ietf.NonceLen - 1];
			Span<byte> pt = stackalloc byte[16];
			Span<byte> ct = stackalloc byte[16];
			CryptoStreamChaCha20Ietf.Encrypt(key, nonce, pt, ct);
		});
	}

	[Test]
	public void EncryptDecrypt_Stream_ShouldRoundtrip()
	{
		Span<byte> key = stackalloc byte[CryptoStreamChaCha20Ietf.KeyLen];
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20Ietf.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream test over Stream");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamChaCha20Ietf.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamChaCha20Ietf.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_ShouldRoundtrip()
	{
		byte[] key = new byte[CryptoStreamChaCha20Ietf.KeyLen];
		byte[] nonce = new byte[CryptoStreamChaCha20Ietf.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("async stream encryption test");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamChaCha20Ietf.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamChaCha20Ietf.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamChaCha20Ietf.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20Ietf.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure stream test");
		Span<byte> ciphertext = stackalloc byte[plaintext.Length];
		Span<byte> decrypted = stackalloc byte[plaintext.Length];

		CryptoStreamChaCha20Ietf.Encrypt(key, nonce, plaintext, ciphertext);
		CryptoStreamChaCha20Ietf.Decrypt(key, nonce, ciphertext, decrypted);

		decrypted.ShouldBe(plaintext);
	}

	[Test]
	public void EncryptDecrypt_Stream_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamChaCha20Ietf.KeyLen);
		Span<byte> nonce = stackalloc byte[CryptoStreamChaCha20Ietf.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("stream encryption test");
		using var input = new MemoryStream(plaintext);
		using var encrypted = new MemoryStream();
		using var decrypted = new MemoryStream();

		CryptoStreamChaCha20Ietf.Encrypt(key, nonce, input, encrypted);

		encrypted.Position = 0;
		CryptoStreamChaCha20Ietf.Decrypt(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}

	[Test]
	public async Task EncryptDecrypt_StreamAsync_WithSecureMemoryKey_ShouldRoundtrip()
	{
		using var key = SecureMemory.Create<byte>(CryptoStreamChaCha20Ietf.KeyLen);
		byte[] nonce = new byte[CryptoStreamChaCha20Ietf.NonceLen];
		RandomGenerator.Fill(key);
		RandomGenerator.Fill(nonce);

		var plaintext = Encoding.UTF8.GetBytes("secure async stream");
		await using var input = new MemoryStream(plaintext);
		await using var encrypted = new MemoryStream();
		await using var decrypted = new MemoryStream();

		await CryptoStreamChaCha20Ietf.EncryptAsync(key, nonce, input, encrypted);

		encrypted.Position = 0;
		await CryptoStreamChaCha20Ietf.DecryptAsync(key, nonce, encrypted, decrypted);

		var result = decrypted.ToArray();
		result.ShouldBe(plaintext);
	}
}

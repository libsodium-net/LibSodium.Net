# üîê AEAD Guide

# üîê AEAD Algorithms

LibSodium.Net provides a unified API for all AEAD (Authenticated Encryption with Associated Data) constructions available in libsodium. These algorithms offer both confidentiality and authenticity, and support optional additional data (AAD) for contextual authentication.

Each algorithm supports both **combined mode** (MAC is part of the ciphertext) and **detached mode** (MAC is separate), and allows **automatic** or **manual** nonce handling.

> üßÇ Based on libsodium's [AEAD constructions](https://doc.libsodium.org/secret-key_cryptography/aead)

---

## ‚öñÔ∏è Algorithm Comparison (len in bytes)

| Algorithm                                                           | KeyLen | NonceLen | MacLen |
| ------------------------------------------------------------------- | ------ | -------- | ------ |
| [XChaCha20-Poly1305](../api/LibSodium.XChaCha20Poly1305.yml)        | 32     | 24       | 16     |
| [ChaCha20-Poly1305-IETF](../api/LibSodium.ChaCha20Poly1305Ietf.yml) | 32     | 12       | 16     |
| [ChaCha20-Poly1305](../api/LibSodium.ChaCha20Poly1305.yml)          | 32     | 8        | 16     |
| [AES256-GCM](../api/LibSodium.Aes256Gcm.yml)                        | 32     | 12       | 16     |
| [AEGIS-256](../api/LibSodium.Aegis256.yml)                          | 32     | 32       | 32     |
| [AEGIS-128L](../api/LibSodium.Aegis128L.yml)                        | 32     | 16       | 32     |

---

## üóùÔ∏è Encrypting and Decrypting

Use the `Encrypt` and `Decrypt` methods from any `LibSodium.<Algorithm>` class. The API automatically chooses **combined** or **detached** mode based on the presence of the optional `mac` parameter.

All AEAD algorithms share the same API:

```csharp
public static Span<byte> Encrypt(
    Span<byte> ciphertext,
    ReadOnlySpan<byte> plaintext,
    ReadOnlySpan<byte> key,
    Span<byte> mac = default,
    ReadOnlySpan<byte> aad = default,
    ReadOnlySpan<byte> nonce = default)
```

```csharp
public static Span<byte> Decrypt(
    Span<byte> plaintext,
    ReadOnlySpan<byte> ciphertext,
    ReadOnlySpan<byte> key,
    ReadOnlySpan<byte> mac = default,
    ReadOnlySpan<byte> aad = default,
    ReadOnlySpan<byte> nonce = default)
```

---

## üìã Example 1: AEGIS-256 (Combined mode with auto nonce and AAD)

```csharp
Span<byte> key = stackalloc byte[Aegis256.KeyLen];
RandomGenerator.Fill(key);

var plaintext = Encoding.UTF8.GetBytes("Secret message");
var aad = Encoding.UTF8.GetBytes("authenticated context");

var ciphertext = new byte[plaintext.Length + Aegis256.MacLen + Aegis256.NonceLen];
Aegis256.Encrypt(ciphertext, plaintext, key, aad: aad);

var decrypted = new byte[plaintext.Length];
Aegis256.Decrypt(decrypted, ciphertext, key, aad: aad);

SecureMemory.MemZero(key);

Console.WriteLine(Encoding.UTF8.GetString(decrypted));
```

---

## üìã Example 2: ChaCha20-Poly1305 (Combined mode with AAD, incrementing manual nonce to prevent reuse)

```csharp
Span<byte> key = stackalloc byte[ChaCha20Poly1305.KeyLen];
Span<byte> nonce = stackalloc byte[ChaCha20Poly1305.NonceLen];
RandomGenerator.Fill(key);
RandomGenerator.Fill(nonce);

var aad = Encoding.UTF8.GetBytes("v1");

var message1 = Encoding.UTF8.GetBytes("First message");
var ciphertext1 = new byte[message1.Length + ChaCha20Poly1305.MacLen];
ChaCha20Poly1305.Encrypt(ciphertext1, message1, key, aad: aad, nonce: nonce);

SecureBigUnsignedInteger.Increment(nonce); // increment to prevent reuse (nonce is only 8 bytes)

var message2 = Encoding.UTF8.GetBytes("Second message");
var ciphertext2 = new byte[message2.Length + ChaCha20Poly1305.MacLen];
ChaCha20Poly1305.Encrypt(ciphertext2, message2, key, aad: aad, nonce: nonce);

SecureMemory.MemZero(key);
```

---

## ‚ö†Ô∏è Error Handling

* `ArgumentException` ‚Äî invalid input lengths or buffer sizes.
* `LibSodiumException` ‚Äî authentication failure (e.g., tampered data).

---

## üìù Notes

* All optional parameters (`mac`, `aad`, `nonce`) should be passed using **named arguments** for clarity and safety (e.g., `aad: data`).
* Nonces must match the algorithm's required length.
* If omitted, a random nonce is generated automatically and prepended to the ciphertext.
* Buffers must be large enough to hold output.
* AAD is optional, but highly recommended.
* Combined mode includes the MAC within the ciphertext.

---

## üëÄ See Also

* [libsodium AEAD constructions](https://doc.libsodium.org/secret-key_cryptography/aead)
* [API Reference](../api/LibSodium.yml)

---

# üß¨ AEAD.cs

```csharp
Ôªø
// <auto-generated />

namespace LibSodium
{
    /// <summary>
    /// Provides high-level access to the XChaCha20-Poly1305 AEAD construction from Libsodium.
    /// </summary>
    /// <remarks>
    /// This class supports both combined and detached modes of authenticated encryption.
    /// It also supports automatic nonce generation when not provided explicitly.
    /// </remarks>
    public static class XChaCha20Poly1305
    {
        /// <summary>
        /// Key length in bytes (32).
        /// </summary>
        public static int KeyLen => LowLevel.XChaCha20Poly1305.KeyLen;

        /// <summary>
        /// Nonce length in bytes (24).
        /// </summary>
        public static int NonceLen => LowLevel.XChaCha20Poly1305.NonceLen;

        /// <summary>
        /// MAC length in bytes (16).
        /// </summary>
        public static int MacLen => LowLevel.XChaCha20Poly1305.MacLen;

        /// <summary>
        /// Encrypts a message using XChaCha20-Poly1305. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="ciphertext">The buffer where the ciphertext will be written. It can be longer than needed.</param>
        /// <param name="plaintext">The message to encrypt.</param>
        /// <param name="key">The secret encryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here.
        /// Otherwise, combined mode is used.
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Not encrypted, but authenticated.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended.
        /// </param>
        /// <returns>
        /// The span representing the full ciphertext, including MAC and possibly nonce.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when encryption fails.</exception>
        public static Span<byte> Encrypt(
            Span<byte> ciphertext,
            ReadOnlySpan<byte> plaintext,
            ReadOnlySpan<byte> key,
            Span<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.XChaCha20Poly1305>.Encrypt(ciphertext, plaintext, key, mac, aad, nonce);

        /// <summary>
        /// Decrypts a message using XChaCha20-Poly1305. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="plaintext">The buffer where the decrypted message will be written.</param>
        /// <param name="ciphertext">
        /// The encrypted message. May include MAC and nonce (combined) or exclude them (detached).
        /// </param>
        /// <param name="key">The secret decryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used..
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Must match what was used for encryption.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (24 bytes). Required for manual nonce mode.
        /// </param>
        /// <returns>The span representing the decrypted plaintext.</returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
        public static Span<byte> Decrypt(
            Span<byte> plaintext,
            ReadOnlySpan<byte> ciphertext,
            ReadOnlySpan<byte> key,
            ReadOnlySpan<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.XChaCha20Poly1305>.Decrypt(plaintext, ciphertext, key, mac, aad, nonce);
    }

    /// <summary>
    /// Provides high-level access to the AEGIS-256 AEAD construction from Libsodium.
    /// </summary>
    /// <remarks>
    /// This class supports both combined and detached modes of authenticated encryption.
    /// It also supports automatic nonce generation when not provided explicitly.
    /// </remarks>
    public static class Aegis256
    {
        /// <summary>
        /// Key length in bytes (32).
        /// </summary>
        public static int KeyLen => LowLevel.Aegis256.KeyLen;

        /// <summary>
        /// Nonce length in bytes (32).
        /// </summary>
        public static int NonceLen => LowLevel.Aegis256.NonceLen;

        /// <summary>
        /// MAC length in bytes (32).
        /// </summary>
        public static int MacLen => LowLevel.Aegis256.MacLen;

        /// <summary>
        /// Encrypts a message using AEGIS-256. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="ciphertext">The buffer where the ciphertext will be written. It can be longer than needed.</param>
        /// <param name="plaintext">The message to encrypt.</param>
        /// <param name="key">The secret encryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here.
        /// Otherwise, combined mode is used.
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Not encrypted, but authenticated.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (32 bytes). If not provided, a random nonce is generated and prepended.
        /// </param>
        /// <returns>
        /// The span representing the full ciphertext, including MAC and possibly nonce.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when encryption fails.</exception>
        public static Span<byte> Encrypt(
            Span<byte> ciphertext,
            ReadOnlySpan<byte> plaintext,
            ReadOnlySpan<byte> key,
            Span<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.Aegis256>.Encrypt(ciphertext, plaintext, key, mac, aad, nonce);

        /// <summary>
        /// Decrypts a message using AEGIS-256. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="plaintext">The buffer where the decrypted message will be written.</param>
        /// <param name="ciphertext">
        /// The encrypted message. May include MAC and nonce (combined) or exclude them (detached).
        /// </param>
        /// <param name="key">The secret decryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used..
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Must match what was used for encryption.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (32 bytes). Required for manual nonce mode.
        /// </param>
        /// <returns>The span representing the decrypted plaintext.</returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
        public static Span<byte> Decrypt(
            Span<byte> plaintext,
            ReadOnlySpan<byte> ciphertext,
            ReadOnlySpan<byte> key,
            ReadOnlySpan<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.Aegis256>.Decrypt(plaintext, ciphertext, key, mac, aad, nonce);
    }

    /// <summary>
    /// Provides high-level access to the AES256-GCM AEAD construction from Libsodium.
    /// </summary>
    /// <remarks>
    /// This class supports both combined and detached modes of authenticated encryption.
    /// It also supports automatic nonce generation when not provided explicitly.
    /// </remarks>
    public static class Aes256Gcm
    {
        /// <summary>
        /// Key length in bytes (32).
        /// </summary>
        public static int KeyLen => LowLevel.Aes256Gcm.KeyLen;

        /// <summary>
        /// Nonce length in bytes (12).
        /// </summary>
        public static int NonceLen => LowLevel.Aes256Gcm.NonceLen;

        /// <summary>
        /// MAC length in bytes (16).
        /// </summary>
        public static int MacLen => LowLevel.Aes256Gcm.MacLen;

        /// <summary>
        /// Encrypts a message using AES256-GCM. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="ciphertext">The buffer where the ciphertext will be written. It can be longer than needed.</param>
        /// <param name="plaintext">The message to encrypt.</param>
        /// <param name="key">The secret encryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here.
        /// Otherwise, combined mode is used.
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Not encrypted, but authenticated.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended.
        /// </param>
        /// <returns>
        /// The span representing the full ciphertext, including MAC and possibly nonce.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when encryption fails.</exception>
        public static Span<byte> Encrypt(
            Span<byte> ciphertext,
            ReadOnlySpan<byte> plaintext,
            ReadOnlySpan<byte> key,
            Span<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.Aes256Gcm>.Encrypt(ciphertext, plaintext, key, mac, aad, nonce);

        /// <summary>
        /// Decrypts a message using AES256-GCM. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="plaintext">The buffer where the decrypted message will be written.</param>
        /// <param name="ciphertext">
        /// The encrypted message. May include MAC and nonce (combined) or exclude them (detached).
        /// </param>
        /// <param name="key">The secret decryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used..
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Must match what was used for encryption.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (12 bytes). Required for manual nonce mode.
        /// </param>
        /// <returns>The span representing the decrypted plaintext.</returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
        public static Span<byte> Decrypt(
            Span<byte> plaintext,
            ReadOnlySpan<byte> ciphertext,
            ReadOnlySpan<byte> key,
            ReadOnlySpan<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.Aes256Gcm>.Decrypt(plaintext, ciphertext, key, mac, aad, nonce);
    }

    /// <summary>
    /// Provides high-level access to the IETF variant of the ChaCha20-Poly1305 AEAD construction from Libsodium.
    /// </summary>
    /// <remarks>
    /// This class supports both combined and detached modes of authenticated encryption.
    /// It also supports automatic nonce generation when not provided explicitly.
    /// </remarks>
    public static class ChaCha20Poly1305Ietf
    {
        /// <summary>
        /// Key length in bytes (32).
        /// </summary>
        public static int KeyLen => LowLevel.ChaCha20Poly1305Ietf.KeyLen;

        /// <summary>
        /// Nonce length in bytes (12).
        /// </summary>
        public static int NonceLen => LowLevel.ChaCha20Poly1305Ietf.NonceLen;

        /// <summary>
        /// MAC length in bytes (16).
        /// </summary>
        public static int MacLen => LowLevel.ChaCha20Poly1305Ietf.MacLen;

        /// <summary>
        /// Encrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="ciphertext">The buffer where the ciphertext will be written. It can be longer than needed.</param>
        /// <param name="plaintext">The message to encrypt.</param>
        /// <param name="key">The secret encryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here.
        /// Otherwise, combined mode is used.
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Not encrypted, but authenticated.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended.
        /// </param>
        /// <returns>
        /// The span representing the full ciphertext, including MAC and possibly nonce.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when encryption fails.</exception>
        public static Span<byte> Encrypt(
            Span<byte> ciphertext,
            ReadOnlySpan<byte> plaintext,
            ReadOnlySpan<byte> key,
            Span<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.ChaCha20Poly1305Ietf>.Encrypt(ciphertext, plaintext, key, mac, aad, nonce);

        /// <summary>
        /// Decrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="plaintext">The buffer where the decrypted message will be written.</param>
        /// <param name="ciphertext">
        /// The encrypted message. May include MAC and nonce (combined) or exclude them (detached).
        /// </param>
        /// <param name="key">The secret decryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used..
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Must match what was used for encryption.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (12 bytes). Required for manual nonce mode.
        /// </param>
        /// <returns>The span representing the decrypted plaintext.</returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
        public static Span<byte> Decrypt(
            Span<byte> plaintext,
            ReadOnlySpan<byte> ciphertext,
            ReadOnlySpan<byte> key,
            ReadOnlySpan<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.ChaCha20Poly1305Ietf>.Decrypt(plaintext, ciphertext, key, mac, aad, nonce);
    }

    /// <summary>
    /// Provides high-level access to the ChaCha20-Poly1305 AEAD construction from Libsodium.
    /// </summary>
    /// <remarks>
    /// This class supports both combined and detached modes of authenticated encryption.
    /// It also supports automatic nonce generation when not provided explicitly.
    /// </remarks>
    public static class ChaCha20Poly1305
    {
        /// <summary>
        /// Key length in bytes (32).
        /// </summary>
        public static int KeyLen => LowLevel.ChaCha20Poly1305.KeyLen;

        /// <summary>
        /// Nonce length in bytes (8).
        /// </summary>
        public static int NonceLen => LowLevel.ChaCha20Poly1305.NonceLen;

        /// <summary>
        /// MAC length in bytes (16).
        /// </summary>
        public static int MacLen => LowLevel.ChaCha20Poly1305.MacLen;

        /// <summary>
        /// Encrypts a message using ChaCha20-Poly1305. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="ciphertext">The buffer where the ciphertext will be written. It can be longer than needed.</param>
        /// <param name="plaintext">The message to encrypt.</param>
        /// <param name="key">The secret encryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here.
        /// Otherwise, combined mode is used.
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Not encrypted, but authenticated.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (8 bytes). If not provided, a random nonce is generated and prepended.
        /// </param>
        /// <returns>
        /// The span representing the full ciphertext, including MAC and possibly nonce.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when encryption fails.</exception>
        public static Span<byte> Encrypt(
            Span<byte> ciphertext,
            ReadOnlySpan<byte> plaintext,
            ReadOnlySpan<byte> key,
            Span<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.ChaCha20Poly1305>.Encrypt(ciphertext, plaintext, key, mac, aad, nonce);

        /// <summary>
        /// Decrypts a message using ChaCha20-Poly1305. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="plaintext">The buffer where the decrypted message will be written.</param>
        /// <param name="ciphertext">
        /// The encrypted message. May include MAC and nonce (combined) or exclude them (detached).
        /// </param>
        /// <param name="key">The secret decryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used..
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Must match what was used for encryption.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (8 bytes). Required for manual nonce mode.
        /// </param>
        /// <returns>The span representing the decrypted plaintext.</returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
        public static Span<byte> Decrypt(
            Span<byte> plaintext,
            ReadOnlySpan<byte> ciphertext,
            ReadOnlySpan<byte> key,
            ReadOnlySpan<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.ChaCha20Poly1305>.Decrypt(plaintext, ciphertext, key, mac, aad, nonce);
    }

    /// <summary>
    /// Provides high-level access to the AEGIS-128L AEAD construction from Libsodium.
    /// </summary>
    /// <remarks>
    /// This class supports both combined and detached modes of authenticated encryption.
    /// It also supports automatic nonce generation when not provided explicitly.
    /// </remarks>
    public static class Aegis128L
    {
        /// <summary>
        /// Key length in bytes (32).
        /// </summary>
        public static int KeyLen => LowLevel.Aegis128L.KeyLen;

        /// <summary>
        /// Nonce length in bytes (16).
        /// </summary>
        public static int NonceLen => LowLevel.Aegis128L.NonceLen;

        /// <summary>
        /// MAC length in bytes (32).
        /// </summary>
        public static int MacLen => LowLevel.Aegis128L.MacLen;

        /// <summary>
        /// Encrypts a message using AEGIS-128L. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="ciphertext">The buffer where the ciphertext will be written. It can be longer than needed.</param>
        /// <param name="plaintext">The message to encrypt.</param>
        /// <param name="key">The secret encryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here.
        /// Otherwise, combined mode is used.
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Not encrypted, but authenticated.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (16 bytes). If not provided, a random nonce is generated and prepended.
        /// </param>
        /// <returns>
        /// The span representing the full ciphertext, including MAC and possibly nonce.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when encryption fails.</exception>
        public static Span<byte> Encrypt(
            Span<byte> ciphertext,
            ReadOnlySpan<byte> plaintext,
            ReadOnlySpan<byte> key,
            Span<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.Aegis128L>.Encrypt(ciphertext, plaintext, key, mac, aad, nonce);

        /// <summary>
        /// Decrypts a message using AEGIS-128L. Supports combined and detached modes,
        /// with optional AAD and nonce.
        /// </summary>
        /// <param name="plaintext">The buffer where the decrypted message will be written.</param>
        /// <param name="ciphertext">
        /// The encrypted message. May include MAC and nonce (combined) or exclude them (detached).
        /// </param>
        /// <param name="key">The secret decryption key (32 bytes).</param>
        /// <param name="mac">
        /// Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used..
        /// </param>
        /// <param name="aad">
        /// Optional additional authenticated data. Must match what was used for encryption.
        /// </param>
        /// <param name="nonce">
        /// Optional nonce (16 bytes). Required for manual nonce mode.
        /// </param>
        /// <returns>The span representing the decrypted plaintext.</returns>
        /// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
        /// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
        public static Span<byte> Decrypt(
            Span<byte> plaintext,
            ReadOnlySpan<byte> ciphertext,
            ReadOnlySpan<byte> key,
            ReadOnlySpan<byte> mac = default,
            ReadOnlySpan<byte> aad = default,
            ReadOnlySpan<byte> nonce = default)
            => AeadCore<LowLevel.Aegis128L>.Decrypt(plaintext, ciphertext, key, mac, aad, nonce);
    }

} // namespace LibSodium

```

# ‚öôÔ∏è AeadCore.cs

```csharp
Ôªønamespace LibSodium
{
	internal static class AeadCore<T> where T : LowLevel.IAead
	{
		/// <summary>
		/// Encrypts and authenticates a plaintext using <typeparamref name="T"/> in detached mode with a provided nonce.
		/// </summary>
		/// <param name="ciphertext">The buffer to write the ciphertext into.</param>
		/// <param name="mac">The buffer to write the authentication tag (MAC) into.</param>
		/// <param name="plaintext">The input data to encrypt.</param>
		/// <param name="key">The 32-byte encryption key.</param>
		/// <param name="aad">Optional additional data to authenticate but not encrypt.</param>
		/// <param name="nonce">The 24-byte nonce.</param>
		/// <returns>A slice of <paramref name="ciphertext"/> with the encrypted data.</returns>
		/// <exception cref="ArgumentException">Thrown when inputs do not match expected lengths.</exception>
		/// <exception cref="LibSodiumException">Thrown when encryption fails internally.</exception>

		internal static Span<byte> EncryptDetached(
			Span<byte> ciphertext,
			Span<byte> mac,
			ReadOnlySpan<byte> plaintext,
			ReadOnlySpan<byte> key,
			ReadOnlySpan<byte> aad,
			ReadOnlySpan<byte> nonce)
		{
			if (key.Length != T.KeyLen) throw new ArgumentException($"Key must be {T.KeyLen} bytes");
			if (nonce.Length != T.NonceLen) throw new ArgumentException($"Nonce must be {T.NonceLen} bytes");
			if (mac.Length != T.MacLen) throw new ArgumentException($"MAC must be {T.MacLen} bytes");
			if (ciphertext.Length < plaintext.Length) throw new ArgumentException("Ciphertext buffer too small");

			LibraryInitializer.EnsureInitialized();
			int rc = T.EncryptDetached(ciphertext, mac, plaintext, aad, nonce, key);
			if (rc != 0) throw new LibSodiumException("Detached encryption failed.");
			return ciphertext.Slice(0, plaintext.Length);
		}

		/// <summary>
		/// Encrypts and authenticates a plaintext using <typeparamref name="T"/> in detached mode, generating a random nonce.
		/// </summary>
		/// <param name="ciphertext">The buffer to write the resulting nonce and ciphertext into.</param>
		/// <param name="mac">The buffer to write the authentication tag (MAC) into.</param>
		/// <param name="plaintext">The input data to encrypt.</param>
		/// <param name="key">The 32-byte encryption key.</param>
		/// <param name="aad">Optional additional data to authenticate but not encrypt.</param>
		/// <returns>A slice of <paramref name="ciphertext"/> containing the nonce followed by the ciphertext.</returns>
		/// <exception cref="ArgumentException">Thrown when buffers are too small or key length is invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when encryption fails internally.</exception>
		internal static Span<byte> EncryptDetached(Span<byte> ciphertext, Span<byte> mac, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> aad = default)
		{
			if (ciphertext.Length < plaintext.Length + T.NonceLen) throw new ArgumentException("Ciphertext buffer too small");
			var nonce = ciphertext.Slice(0, T.NonceLen);
			RandomGenerator.Fill(nonce);
			var cipher = ciphertext.Slice(T.NonceLen);
			EncryptDetached(cipher, mac, plaintext, key, aad, nonce);
			return ciphertext.Slice(0, plaintext.Length + T.NonceLen);
		}

		/// <summary>
		/// Decrypts a ciphertext with an authentication tag using detached mode.
		/// </summary>
		/// <param name="plaintext">The buffer to write the decrypted data.</param>
		/// <param name="ciphertext">The encrypted data.</param>
		/// <param name="key">The decryption key.</param>
		/// <param name="mac">The authentication tag (MAC).</param>
		/// <param name="additionalData">Optional additional authenticated data.</param>
		/// <param name="nonce">The nonce used during encryption.</param>
		/// <returns>A slice of <paramref name="plaintext"/> with the decrypted data.</returns>
		/// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
		internal static Span<byte> DecryptDetached(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac, ReadOnlySpan<byte> additionalData, ReadOnlySpan<byte> nonce)
		{
			if (key.Length != T.KeyLen) throw new ArgumentException($"Key must be {T.KeyLen} bytes");
			if (nonce.Length != T.NonceLen) throw new ArgumentException($"Nonce must be {T.NonceLen} bytes");
			if (mac.Length != T.MacLen) throw new ArgumentException($"MAC must be {T.MacLen} bytes");
			if (plaintext.Length < ciphertext.Length) throw new ArgumentException("Plaintext buffer too small");

			LibraryInitializer.EnsureInitialized();
			int rc = T.DecryptDetached(plaintext, ciphertext, mac, additionalData, nonce, key);
			if (rc != 0) throw new LibSodiumException("Detached decryption failed or MAC verification failed.");
			return plaintext.Slice(0, ciphertext.Length);
		}

		/// <summary>
		/// Decrypts a ciphertext with an authentication tag using detached mode.
		/// </summary>
		/// <param name="plaintext">The buffer to write the decrypted data.</param>
		/// <param name="ciphertext">The encrypted data.</param>
		/// <param name="key">The decryption key.</param>
		/// <param name="mac">The authentication tag (MAC).</param>
		/// <param name="additionalData">Optional additional authenticated data.</param>
		/// <returns>A slice of <paramref name="plaintext"/> with the decrypted data.</returns>
		/// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
		internal static Span<byte> DecryptDetached(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac, ReadOnlySpan<byte> additionalData)
		{
			if (ciphertext.Length < T.NonceLen) throw new ArgumentException("Ciphertext too short", nameof(ciphertext));
			if (plaintext.Length < ciphertext.Length - T.NonceLen) throw new ArgumentException("Plaintext buffer too small");
			var nonce = ciphertext.Slice(0, T.NonceLen);
			var cipher = ciphertext.Slice(T.NonceLen);
			return DecryptDetached(plaintext, cipher, key, mac, additionalData, nonce);
		}

		/// <summary>
		/// Encrypts and authenticates plaintext using <typeparamref name="T"/> in combined mode (MAC is appended).
		/// </summary>
		/// <param name="ciphertext">The buffer to write the resulting ciphertext and MAC into.</param>
		/// <param name="plaintext">The data to encrypt.</param>
		/// <param name="key">The encryption key.</param>
		/// <param name="aad">The authenticated additional data</param>
		/// <param name="nonce">The nonce to use for encryption.</param>
		/// <returns>A slice of <paramref name="ciphertext"/> containing the ciphertext and MAC.</returns>
		/// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when encryption fails internally.</exception>
		internal static Span<byte> EncryptCombined(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> aad, ReadOnlySpan<byte> nonce)
		{
			if (ciphertext.Length < plaintext.Length + T.MacLen) throw new ArgumentException("Ciphertext buffer too small");
			if (key.Length != T.KeyLen) throw new ArgumentException($"Key must be {T.KeyLen} bytes");
			if (nonce.Length != T.NonceLen) throw new ArgumentException($"Nonce must be {T.NonceLen} bytes");

			LibraryInitializer.EnsureInitialized();
			int rc = T.EncryptCombined(ciphertext, plaintext, aad, nonce, key);
			if (rc != 0) throw new LibSodiumException("Encryption failed.");
			return ciphertext.Slice(0, plaintext.Length + T.MacLen);
		}

		/// <summary>
		/// Encrypts using combined mode and prepends a randomly generated nonce.
		/// </summary>
		/// <param name="ciphertext">The buffer to store [nonce | ciphertext | MAC].</param>
		/// <param name="plaintext">The data to encrypt.</param>
		/// <param name="key">The encryption key.</param>
		/// <param name="aad">The authenticated additional data</param>
		/// <returns>A slice of <paramref name="ciphertext"/> including the nonce and MAC.</returns>
		/// <exception cref="ArgumentException">Thrown when the buffer is too small or key length is invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when encryption fails internally.</exception>
		internal static Span<byte> EncryptCombined(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> aad = default)
		{
			if (ciphertext.Length < plaintext.Length + T.MacLen + T.NonceLen) throw new ArgumentException("Ciphertext buffer too small");
			var nonce = ciphertext.Slice(0, T.NonceLen);
			RandomGenerator.Fill(nonce);
			var cipher = ciphertext.Slice(T.NonceLen);
			EncryptCombined(cipher, plaintext, key, aad, nonce);
			return ciphertext.Slice(0, plaintext.Length + T.MacLen + T.NonceLen);
		}

		/// <summary>
		/// Decrypts ciphertext in combined mode using the provided nonce.
		/// </summary>
		/// <param name="plaintext">The buffer to write the decrypted data.</param>
		/// <param name="ciphertext">The ciphertext including MAC.</param>
		/// <param name="key">The encryption key.</param>
		/// <param name="aad">The authenticated additional data</param>
		/// <param name="nonce">The nonce used during encryption.</param>
		/// <returns>A slice of <paramref name="plaintext"/> with the decrypted data.</returns>
		/// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
		internal static Span<byte> DecryptCombined(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> aad, ReadOnlySpan<byte> nonce)
		{
			if (ciphertext.Length < T.MacLen) throw new ArgumentException("ciphertext buffer too short");
			if (plaintext.Length < ciphertext.Length - T.MacLen) throw new ArgumentException("Plaintext buffer too small");
			if (key.Length != T.KeyLen) throw new ArgumentException($"Key must be {T.KeyLen} bytes");
			if (nonce.Length != T.NonceLen) throw new ArgumentException($"Nonce must be {T.NonceLen} bytes");

			LibraryInitializer.EnsureInitialized();
			int rc = T.DecryptCombined(plaintext, ciphertext, aad, nonce, key);
			if (rc != 0) throw new LibSodiumException("Decryption failed or MAC verification failed.");
			return plaintext.Slice(0, ciphertext.Length - T.MacLen);
		}

		/// <summary>
		/// Decrypts combined ciphertext that includes a prepended nonce.
		/// </summary>
		/// <param name="plaintext">The buffer to write the plaintext.</param>
		/// <param name="ciphertext">The combined data [nonce | ciphertext | MAC].</param>
		/// <param name="key">The encryption key.</param>
		/// <param name="aad">The authenticated additional data</param>
		/// <returns>A slice of <paramref name="plaintext"/> containing the decrypted data.</returns>
		/// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or ciphertext is too short.</exception>
		/// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
		internal static Span<byte> DecryptCombined(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> aad = default)
		{
			if (ciphertext.Length < T.MacLen + T.NonceLen) throw new ArgumentException("Ciphertext too short");
			var nonce = ciphertext.Slice(0, T.NonceLen);
			var cipher = ciphertext.Slice(T.NonceLen);
			return DecryptCombined(plaintext, cipher, key, aad, nonce);
		}

		/// <summary>
		/// Encrypts a message using <typeparamref name="T"/>. Supports combined and detached modes,
		/// with optional AAD and nonce.
		/// </summary>
		/// <param name="ciphertext">
		/// The buffer where the ciphertext will be written. It can be longer than needed.
		/// In combined mode, it must include space for the MAC and, if auto-nonce is used, the nonce as well.
		/// </param>
		/// <param name="plaintext">The message to encrypt.</param>
		/// <param name="key">The secret encryption key (32 bytes).</param>
		/// <param name="mac">
		/// Optional. If provided, the encryption is done in detached mode and the MAC is written here.
		/// Otherwise, combined mode is used.
		/// </param>
		/// <param name="aad">
		/// Optional additional authenticated data. Not encrypted, but authenticated.
		/// </param>
		/// <param name="nonce">
		/// Optional nonce. If not provided, a random nonce is generated and prepended.
		/// </param>
		/// <returns>
		/// The span representing the full ciphertext, including MAC and possibly nonce.
		/// </returns>
		/// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when encryption fails.</exception>

		public static Span<byte> Encrypt(
			Span<byte> ciphertext,
			ReadOnlySpan<byte> plaintext,
			ReadOnlySpan<byte> key,
			Span<byte> mac = default,
			ReadOnlySpan<byte> aad = default,
			ReadOnlySpan<byte> nonce = default)
		{
			if (mac == default)
			{
				// Combined mode
				if (nonce == default)
					return EncryptCombined(ciphertext, plaintext, key, aad);
				else
					return EncryptCombined(ciphertext, plaintext, key, aad, nonce);
			}
			else
			{
				// Detached mode
				if (nonce == default)
					return EncryptDetached(ciphertext, mac, plaintext, key, aad);
				else
					return EncryptDetached(ciphertext, mac, plaintext, key, aad, nonce);
			}
		}

		/// <summary>
		/// Decrypts a message using <typeparamref name="T"/>. Supports combined and detached modes,
		/// with optional AAD and nonce.
		/// </summary>
		/// <param name="plaintext">The buffer where the decrypted message will be written. It can be longer than needed</param>
		/// <param name="ciphertext">
		/// The encrypted message. May include MAC and nonce (combined) or exclude them (detached).
		/// </param>
		/// <param name="key">The secret decryption key</param>
		/// <param name="mac">
		/// Optional. If provided, decryption is done in detached mode. If null, combined mode is used.
		/// </param>
		/// <param name="aad">
		/// Optional additional authenticated data. Must match what was used for encryption.
		/// </param>
		/// <param name="nonce">
		/// Optional nonce. Required for manual nonce mode.
		/// </param>
		/// <returns>The span representing the decrypted plaintext.</returns>
		/// <exception cref="ArgumentException">Thrown when buffer sizes are incorrect or parameters are invalid.</exception>
		/// <exception cref="LibSodiumException">Thrown when MAC verification fails or decryption fails.</exception>
		public static Span<byte> Decrypt(
			Span<byte> plaintext,
			ReadOnlySpan<byte> ciphertext,
			ReadOnlySpan<byte> key,
			ReadOnlySpan<byte> mac = default,
			ReadOnlySpan<byte> aad = default,
			ReadOnlySpan<byte> nonce = default)
		{
			if (mac == default)
			{
				// Combined mode
				if (nonce == default)
					return DecryptCombined(plaintext, ciphertext, key, aad);
				else
					return DecryptCombined(plaintext, ciphertext, key, aad, nonce);
			}
			else
			{
				// Detached mode
				if (nonce == default)
					return DecryptDetached(plaintext, ciphertext, key, mac, aad);
				else
					return DecryptDetached(plaintext, ciphertext, key, mac, aad, nonce);
			}
		}
	}
}

```

# üß™ AeadCoreTestBase.cs

```csharp
Ôªøusing LibSodium.Tests;

namespace LibSodium.Net.Tests
{

	internal class AeadCoreTestBase<T> where T : LowLevel.IAead
	{

		public static byte[] GenerateRandomBytes(int length)
		{
			var buffer = new byte[length];
			Random.Shared.NextBytes(buffer);
			return buffer;
		}

		public static void EncryptAndDecrypt_Combined_WithAutoNonce()
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var plaintext = GenerateRandomBytes(128);
			var ciphertext = new byte[T.NonceLen + plaintext.Length + T.MacLen];
			var decrypted = new byte[plaintext.Length];

			var actual = AeadCore<T>.Encrypt(ciphertext, plaintext, key);
			var result = AeadCore<T>.Decrypt(decrypted, actual, key);
			result.SequenceEqual(plaintext).ShouldBeTrue();
		}

		public static void EncryptAndDecrypt_Combined_WithManualNonce()
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var nonce = GenerateRandomBytes(T.NonceLen);
			var plaintext = GenerateRandomBytes(128);
			var ciphertext = new byte[plaintext.Length + T.MacLen];
			var decrypted = new byte[plaintext.Length];

			var result = AeadCore<T>.Encrypt(ciphertext, plaintext, key, nonce: nonce);
			var output = AeadCore<T>.Decrypt(decrypted, result, key, nonce: nonce);
			output.SequenceEqual(plaintext).ShouldBeTrue();
		}

		public static void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD()
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var nonce = GenerateRandomBytes(T.NonceLen);
			var aad = GenerateRandomBytes(64);
			var plaintext = GenerateRandomBytes(64);
			var ciphertext = new byte[plaintext.Length];
			var mac = new byte[T.MacLen];
			var decrypted = new byte[plaintext.Length];

			AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
			var result = AeadCore<T>.Decrypt(decrypted, ciphertext, key, mac: mac, aad: aad, nonce: nonce);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();
		}

		public static void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD()
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var plaintext = GenerateRandomBytes(64);
			var ciphertext = new byte[T.NonceLen + plaintext.Length];
			var mac = new byte[T.MacLen];
			var decrypted = new byte[plaintext.Length];

			AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac);
			AeadCore<T>.Decrypt(decrypted, ciphertext, key, mac: mac);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();
		}

		public static void TamperedCiphertext_ShouldThrow()
		{
			AssertLite.Throws<LibSodiumException>(() =>
			{
				var key = GenerateRandomBytes(T.KeyLen);
				var plaintext = GenerateRandomBytes(64);
				var ciphertext = new byte[T.NonceLen + plaintext.Length + T.MacLen];
				var decrypted = new byte[plaintext.Length];
				var result = AeadCore<T>.Encrypt(ciphertext, plaintext, key);
				result[^1] ^= 0xFF;
				AeadCore<T>.Decrypt(decrypted, ciphertext, key);
			});
		}

		public static void InvalidMac_ShouldThrow()
		{
			AssertLite.Throws<LibSodiumException>(() =>
			{
				var key = GenerateRandomBytes(T.KeyLen);
				var nonce = GenerateRandomBytes(T.NonceLen);
				var aad = GenerateRandomBytes(16);
				var plaintext = GenerateRandomBytes(128);
				var ciphertext = new byte[plaintext.Length];
				var mac = new byte[T.MacLen];
				var decrypted = new byte[plaintext.Length];

				AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac, aad, nonce);
				mac[0] ^= 0xFF;
				AeadCore<T>.Decrypt(decrypted, ciphertext, key, mac, aad, nonce);
			});
		}

		public static void InvalidKeyLength_ShouldThrow()
		{
			AssertLite.Throws<ArgumentException>(() =>
			{
				var key = GenerateRandomBytes(T.KeyLen - 1);
				var nonce = GenerateRandomBytes(T.NonceLen);
				var plaintext = GenerateRandomBytes(64);
				var ciphertext = new byte[plaintext.Length];
				var mac = new byte[T.MacLen];
				AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
			});
		}

		public static void InvalidNonceLength_ShouldThrow()
		{


			var key = GenerateRandomBytes(T.KeyLen);
			var nonce = GenerateRandomBytes(T.NonceLen - 1);
			var plaintext = GenerateRandomBytes(64);
			var ciphertext = new byte[plaintext.Length];
			var mac = new byte[T.MacLen];

			AssertLite.Throws<ArgumentException>(() => AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce));
		}

		public static void BufferTooSmall_ShouldThrow()
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var nonce = GenerateRandomBytes(T.NonceLen);
			var plaintext = GenerateRandomBytes(64);
			var ciphertext = new byte[plaintext.Length - 1];
			var mac = new byte[T.MacLen];
			AssertLite.Throws<ArgumentException>(() => AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce));
		}

		public static void EncryptAndDecrypt_Detached_VariousLengths(int size)
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var nonce = GenerateRandomBytes(T.NonceLen);
			var plaintext = GenerateRandomBytes(size);
			var ciphertext = new byte[size];
			var mac = new byte[T.MacLen];
			var decrypted = new byte[size];

			AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
			AeadCore<T>.Decrypt(decrypted, ciphertext, key, mac: mac, nonce: nonce);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();
		}

		public static void AllCombinedOptions()
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var nonce = GenerateRandomBytes(T.NonceLen);
			var plaintext = GenerateRandomBytes(64);
			var ciphertext = new byte[T.NonceLen + plaintext.Length + T.MacLen];
			var decrypted = new byte[plaintext.Length];
			var aad = GenerateRandomBytes(16);
			Span<byte> encrypted;

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key);
			AeadCore<T>.Decrypt(decrypted, encrypted, key);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key, aad: aad);
			AeadCore<T>.Decrypt(decrypted, encrypted, key, aad: aad);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
			AeadCore<T>.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key, nonce: nonce);
			AeadCore<T>.Decrypt(decrypted, encrypted, key, nonce: nonce);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();
		}

		public static void AllDetachedOptions()
		{
			var key = GenerateRandomBytes(T.KeyLen);
			var nonce = GenerateRandomBytes(T.NonceLen);
			var plaintext = GenerateRandomBytes(64);
			var ciphertext = new byte[T.NonceLen + plaintext.Length];
			var decrypted = new byte[plaintext.Length];
			var aad = GenerateRandomBytes(16);
			var mac = new byte[T.MacLen];

			Span<byte> encrypted;

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac);
			AeadCore<T>.Decrypt(decrypted, encrypted, key, mac: mac);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
			AeadCore<T>.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
			AeadCore<T>.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();

			encrypted = AeadCore<T>.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
			AeadCore<T>.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
			decrypted.SequenceEqual(plaintext).ShouldBeTrue();
		}
	}
}

```

# üß™ AeadTests.cs

```csharp
Ôªø
// <auto-generated />
using LibSodium.Net.Tests;
using System.Text;

namespace LibSodium.Tests
{
    public class XChaCha20Poly1305Tests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[XChaCha20Poly1305.NonceLen + plaintext.Length + XChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(XChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.XChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[XChaCha20Poly1305.NonceLen + plaintext.Length + XChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[XChaCha20Poly1305.MacLen];
            Span<byte> encrypted;

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            XChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + XChaCha20Poly1305.MacLen + XChaCha20Poly1305.NonceLen];
            XChaCha20Poly1305.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class Aegis256Tests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis256>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.Aegis256>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis256.NonceLen + plaintext.Length + Aegis256.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key);
            Aegis256.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, aad: aad);
            Aegis256.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(Aegis256.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis256>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis256.NonceLen + plaintext.Length + Aegis256.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[Aegis256.MacLen];
            Span<byte> encrypted;

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis256.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            Aegis256.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[Aegis256.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + Aegis256.MacLen + Aegis256.NonceLen];
            Aegis256.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            Aegis256.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class Aes256GcmTests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.Aes256Gcm>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aes256Gcm.NonceLen + plaintext.Length + Aes256Gcm.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key);
            Aes256Gcm.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, aad: aad);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(Aes256Gcm.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aes256Gcm>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aes256Gcm.NonceLen + plaintext.Length + Aes256Gcm.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[Aes256Gcm.MacLen];
            Span<byte> encrypted;

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            Aes256Gcm.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[Aes256Gcm.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + Aes256Gcm.MacLen + Aes256Gcm.NonceLen];
            Aes256Gcm.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            Aes256Gcm.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class ChaCha20Poly1305IetfTests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305Ietf.NonceLen + plaintext.Length + ChaCha20Poly1305Ietf.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, aad: aad);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(ChaCha20Poly1305Ietf.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305Ietf>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305Ietf.NonceLen + plaintext.Length + ChaCha20Poly1305Ietf.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[ChaCha20Poly1305Ietf.MacLen];
            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305Ietf.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            ChaCha20Poly1305Ietf.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[ChaCha20Poly1305Ietf.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + ChaCha20Poly1305Ietf.MacLen + ChaCha20Poly1305Ietf.NonceLen];
            ChaCha20Poly1305Ietf.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            ChaCha20Poly1305Ietf.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class ChaCha20Poly1305Tests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305.NonceLen + plaintext.Length + ChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(ChaCha20Poly1305.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.ChaCha20Poly1305>.GenerateRandomBytes(64);
            var ciphertext = new byte[ChaCha20Poly1305.NonceLen + plaintext.Length + ChaCha20Poly1305.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[ChaCha20Poly1305.MacLen];
            Span<byte> encrypted;

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = ChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            ChaCha20Poly1305.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[ChaCha20Poly1305.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + ChaCha20Poly1305.MacLen + ChaCha20Poly1305.NonceLen];
            ChaCha20Poly1305.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            ChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
    public class Aegis128LTests
    {
        [Test]
        public void EncryptAndDecrypt_Combined_WithAutoNonce() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Combined_WithAutoNonce();

        [Test]
        public void EncryptAndDecrypt_Combined_WithManualNonce() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Combined_WithManualNonce();

        [Test]
        public void EncryptAndDecrypt_Detached_WithManualNonce_AndAAD() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Detached_WithManualNonce_AndAAD();

        [Test]
        public void EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Detached_WithAutoNonce_AndNoAAD();

        [Test]
        public void TamperedCiphertext_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.TamperedCiphertext_ShouldThrow();

        [Test]
        public void InvalidMac_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.InvalidMac_ShouldThrow();

        [Test]
        public void InvalidKeyLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.InvalidKeyLength_ShouldThrow();

        [Test]
        public void InvalidNonceLength_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.InvalidNonceLength_ShouldThrow();

        [Test]
        public void BufferTooSmall_ShouldThrow() =>
            AeadCoreTestBase<LowLevel.Aegis128L>.BufferTooSmall_ShouldThrow();

        [Test]
        [Arguments(0)]
        [Arguments(1)]
        [Arguments(16)]
        [Arguments(64)]
        [Arguments(1024)]
        public void EncryptAndDecrypt_Detached_VariousLengths(int size) =>
            AeadCoreTestBase<LowLevel.Aegis128L>.EncryptAndDecrypt_Detached_VariousLengths(size);

        [Test]
        public void AllCombinedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis128L.NonceLen + plaintext.Length + Aegis128L.MacLen];
            var decrypted = new byte[plaintext.Length];

            Span<byte> encrypted;

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key);
            Aegis128L.Decrypt(decrypted, encrypted, key);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, aad: aad);
            Aegis128L.Decrypt(decrypted, encrypted, key, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void AllDetachedOptions()
        {
            var key = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.KeyLen);
            var nonce = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(Aegis128L.NonceLen);
            var aad = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(16);
            var plaintext = AeadCoreTestBase<LowLevel.Aegis128L>.GenerateRandomBytes(64);
            var ciphertext = new byte[Aegis128L.NonceLen + plaintext.Length + Aegis128L.MacLen];
            var decrypted = new byte[plaintext.Length];

            var mac = new byte[Aegis128L.MacLen];
            Span<byte> encrypted;

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac, aad: aad, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac, aad: aad, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();

            encrypted = Aegis128L.Encrypt(ciphertext, plaintext, key, mac: mac, nonce: nonce);
            Aegis128L.Decrypt(decrypted, encrypted, key, mac: mac, nonce: nonce);
            decrypted.SequenceEqual(plaintext).ShouldBeTrue();
        }

        [Test]
        public void Sample()
        {
            // encrypting and decrypting with additional data, automatic nonce and combined mode (includes MAC)
            Span<byte> key = stackalloc byte[Aegis128L.KeyLen];
            RandomGenerator.Fill(key);

            var aad = Encoding.UTF8.GetBytes("context");
            var data = Encoding.UTF8.GetBytes("Hello");

            var ciphertext = new byte[data.Length + Aegis128L.MacLen + Aegis128L.NonceLen];
            Aegis128L.Encrypt(ciphertext, data, key, aad: aad);

            var decrypted = new byte[data.Length];
            Aegis128L.Decrypt(decrypted, ciphertext, key, aad: aad);

            SecureMemory.MemZero(key);

            decrypted.SequenceEqual(data).ShouldBeTrue();
        }
    }
}

```


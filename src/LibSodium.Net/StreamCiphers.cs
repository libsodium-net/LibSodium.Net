

// <auto-generated />

namespace LibSodium
{
	/// <summary>
	/// Provides high-level access to the <c>XSalsa20</c> stream cipher.
	/// </summary>
	public static class CryptoStreamXSalsa20
	{
		/// <summary>Length of the secret key in bytes (32).</summary>
		public static readonly int KeyLen = LowLevel.XSalsa20Cipher.KeyLen;

		/// <summary>Length of the nonce in bytes (24).</summary>
		public static readonly int NonceLen = LowLevel.XSalsa20Cipher.NonceLen;

		/// <summary>Block size of the keystream in bytes (64).</summary>
		public static readonly int BlockLen = LowLevel.XSalsa20Cipher.BlockLen;

		/// <summary>
        /// Encrypts the given plaintext using the <c>XSalsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Encrypt(key, nonce, plaintext, ciphertext);

        /// <summary>
        /// Encrypts the given plaintext using the <c>XSalsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, plaintext, ciphertext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>XSalsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Decrypt(key, nonce, ciphertext, plaintext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>XSalsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, ciphertext, plaintext);


		/// <summary>
        /// Encrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Encrypt(key, nonce, input, output);


        /// <summary>
        /// Encrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Decrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Decrypt(key, nonce, input, output);

        /// <summary>
        /// Decrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.EncryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.EncryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Asynchronously decrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.DecryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously decrypts a stream using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.DecryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Generates a keystream of the specified length using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.GenerateKeystream(output, nonce, key);

		/// <summary>
        /// Generates a keystream of the specified length using the <c>XSalsa20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key)
			=> CryptoStreamCipher<LowLevel.XSalsa20Cipher>.GenerateKeystream(output.AsSpan(), nonce, key.AsReadOnlySpan());

	}
	/// <summary>
	/// Provides high-level access to the <c>Salsa20</c> stream cipher.
	/// </summary>
	public static class CryptoStreamSalsa20
	{
		/// <summary>Length of the secret key in bytes (32).</summary>
		public static readonly int KeyLen = LowLevel.Salsa20Cipher.KeyLen;

		/// <summary>Length of the nonce in bytes (8).</summary>
		public static readonly int NonceLen = LowLevel.Salsa20Cipher.NonceLen;

		/// <summary>Block size of the keystream in bytes (64).</summary>
		public static readonly int BlockLen = LowLevel.Salsa20Cipher.BlockLen;

		/// <summary>
        /// Encrypts the given plaintext using the <c>Salsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Encrypt(key, nonce, plaintext, ciphertext);

        /// <summary>
        /// Encrypts the given plaintext using the <c>Salsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, plaintext, ciphertext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>Salsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Decrypt(key, nonce, ciphertext, plaintext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>Salsa20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, ciphertext, plaintext);


		/// <summary>
        /// Encrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Encrypt(key, nonce, input, output);


        /// <summary>
        /// Encrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Decrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Decrypt(key, nonce, input, output);

        /// <summary>
        /// Decrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.EncryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.EncryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Asynchronously decrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.DecryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously decrypts a stream using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.DecryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Generates a keystream of the specified length using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.GenerateKeystream(output, nonce, key);

		/// <summary>
        /// Generates a keystream of the specified length using the <c>Salsa20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key)
			=> CryptoStreamCipher<LowLevel.Salsa20Cipher>.GenerateKeystream(output.AsSpan(), nonce, key.AsReadOnlySpan());

	}
	/// <summary>
	/// Provides high-level access to the <c>ChaCha20</c> stream cipher.
	/// </summary>
	public static class CryptoStreamChaCha20
	{
		/// <summary>Length of the secret key in bytes (32).</summary>
		public static readonly int KeyLen = LowLevel.ChaCha20Cipher.KeyLen;

		/// <summary>Length of the nonce in bytes (8).</summary>
		public static readonly int NonceLen = LowLevel.ChaCha20Cipher.NonceLen;

		/// <summary>Block size of the keystream in bytes (64).</summary>
		public static readonly int BlockLen = LowLevel.ChaCha20Cipher.BlockLen;

		/// <summary>
        /// Encrypts the given plaintext using the <c>ChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Encrypt(key, nonce, plaintext, ciphertext);

        /// <summary>
        /// Encrypts the given plaintext using the <c>ChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, plaintext, ciphertext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>ChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Decrypt(key, nonce, ciphertext, plaintext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>ChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, ciphertext, plaintext);


		/// <summary>
        /// Encrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Encrypt(key, nonce, input, output);


        /// <summary>
        /// Encrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Decrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Decrypt(key, nonce, input, output);

        /// <summary>
        /// Decrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>8</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.EncryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.EncryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Asynchronously decrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.DecryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously decrypts a stream using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>8</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.DecryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Generates a keystream of the specified length using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.GenerateKeystream(output, nonce, key);

		/// <summary>
        /// Generates a keystream of the specified length using the <c>ChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>8</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key)
			=> CryptoStreamCipher<LowLevel.ChaCha20Cipher>.GenerateKeystream(output.AsSpan(), nonce, key.AsReadOnlySpan());

	}
	/// <summary>
	/// Provides high-level access to the <c>XChaCha20</c> stream cipher.
	/// </summary>
	public static class CryptoStreamXChaCha20
	{
		/// <summary>Length of the secret key in bytes (32).</summary>
		public static readonly int KeyLen = LowLevel.XChaCha20Cipher.KeyLen;

		/// <summary>Length of the nonce in bytes (24).</summary>
		public static readonly int NonceLen = LowLevel.XChaCha20Cipher.NonceLen;

		/// <summary>Block size of the keystream in bytes (64).</summary>
		public static readonly int BlockLen = LowLevel.XChaCha20Cipher.BlockLen;

		/// <summary>
        /// Encrypts the given plaintext using the <c>XChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Encrypt(key, nonce, plaintext, ciphertext);

        /// <summary>
        /// Encrypts the given plaintext using the <c>XChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, plaintext, ciphertext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>XChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Decrypt(key, nonce, ciphertext, plaintext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>XChaCha20</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, ciphertext, plaintext);


		/// <summary>
        /// Encrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Encrypt(key, nonce, input, output);


        /// <summary>
        /// Encrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Encrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Decrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Decrypt(key, nonce, input, output);

        /// <summary>
        /// Decrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>24</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.Decrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.EncryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.EncryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Asynchronously decrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.DecryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously decrypts a stream using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>24</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.DecryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Generates a keystream of the specified length using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.GenerateKeystream(output, nonce, key);

		/// <summary>
        /// Generates a keystream of the specified length using the <c>XChaCha20</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>24</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key)
			=> CryptoStreamCipher<LowLevel.XChaCha20Cipher>.GenerateKeystream(output.AsSpan(), nonce, key.AsReadOnlySpan());

	}
	/// <summary>
	/// Provides high-level access to the <c>ChaCha20Ietf</c> stream cipher.
	/// </summary>
	public static class CryptoStreamChaCha20Ietf
	{
		/// <summary>Length of the secret key in bytes (32).</summary>
		public static readonly int KeyLen = LowLevel.ChaCha20IetfCipher.KeyLen;

		/// <summary>Length of the nonce in bytes (12).</summary>
		public static readonly int NonceLen = LowLevel.ChaCha20IetfCipher.NonceLen;

		/// <summary>Block size of the keystream in bytes (64).</summary>
		public static readonly int BlockLen = LowLevel.ChaCha20IetfCipher.BlockLen;

		/// <summary>
        /// Encrypts the given plaintext using the <c>ChaCha20Ietf</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Encrypt(key, nonce, plaintext, ciphertext);

        /// <summary>
        /// Encrypts the given plaintext using the <c>ChaCha20Ietf</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes long. Must never be reused with the same key.</param>
        /// <param name="plaintext">The plaintext data to encrypt.</param>
        /// <param name="ciphertext">The output buffer to receive the encrypted data. Must be at least as long as <paramref name="plaintext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// This method XORs the plaintext with a keystream derived from the key and nonce.
        /// </remarks>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Encrypt(key.AsReadOnlySpan(), nonce, plaintext, ciphertext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>ChaCha20Ietf</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>12</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Decrypt(key, nonce, ciphertext, plaintext);

		/// <summary>
        /// Decrypts the given ciphertext using the <c>ChaCha20Ietf</c> stream cipher, with the provided key and nonce.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>12</c> bytes long.</param>
        /// <param name="ciphertext">The ciphertext to decrypt (produced by XOR with keystream).</param>
        /// <param name="plaintext">The output buffer to receive the decrypted plaintext. Must be at least as long as <paramref name="ciphertext"/>.</param>
        /// <param name="initialCounter">
        /// The starting block index for the keystream (each block is 64 bytes).
        /// Use this to skip blocks, resume encryption, or decrypt from a specific offset.
        /// Defaults to 0.
        /// </param>
        /// <exception cref="ArgumentException">Thrown if any input length is invalid.</exception>
        /// <remarks>
        /// Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext.
        /// </remarks>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0L)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Decrypt(key.AsReadOnlySpan(), nonce, ciphertext, plaintext);


		/// <summary>
        /// Encrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Encrypt(key, nonce, input, output);


        /// <summary>
        /// Encrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes long.</param>
        /// <param name="input">The stream containing plaintext data to encrypt.</param>
        /// <param name="output">The stream to receive the encrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Encrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Decrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>12</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Decrypt(key, nonce, input, output);

        /// <summary>
        /// Decrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes long.</param>
        /// <param name="nonce">The nonce used during encryption. Must be exactly <c>12</c> bytes long.</param>
        /// <param name="input">The stream containing ciphertext to decrypt.</param>
        /// <param name="output">The stream to receive the decrypted data.</param>
        /// <exception cref="ArgumentException">Thrown if key or nonce are invalid.</exception>
		public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.Decrypt(key.AsReadOnlySpan(), nonce, input, output);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.EncryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously encrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes.</param>
        /// <param name="input">The readable stream with plaintext data.</param>
        /// <param name="output">The writable stream to receive ciphertext.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.EncryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Asynchronously decrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>12</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.DecryptAsync(key, nonce, input, output, cancellationToken);

		/// <summary>
        /// Asynchronously decrypts a stream using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="key">The secret key. Must be exactly <c>32</c> bytes.</param>
        /// <param name="nonce">The nonce used during encryption. Must be <c>12</c> bytes.</param>
        /// <param name="input">The readable stream with ciphertext.</param>
        /// <param name="output">The writable stream to receive decrypted data.</param>
        /// <param name="cancellationToken">Optional token to cancel the async operation.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
		public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.DecryptAsync(key.AsReadOnlyMemory(), nonce, input, output, cancellationToken);


		/// <summary>
        /// Generates a keystream of the specified length using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.GenerateKeystream(output, nonce, key);

		/// <summary>
        /// Generates a keystream of the specified length using the <c>ChaCha20Ietf</c> stream cipher.
        /// </summary>
        /// <param name="output">The buffer to receive the generated keystream.</param>
        /// <param name="nonce">The nonce. Must be exactly <c>12</c> bytes.</param>
        /// <param name="key">The key. Must be exactly <c>32</c> bytes.</param>
        /// <exception cref="ArgumentException">Thrown if <paramref name="output"/> is empty or lengths are invalid.</exception>
		public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key)
			=> CryptoStreamCipher<LowLevel.ChaCha20IetfCipher>.GenerateKeystream(output.AsSpan(), nonce, key.AsReadOnlySpan());

	}
} // namespace
